# Sudoku-Recognizer
An application in Python with OpenCV that digitize a Sudoku on a picture.
https://github.com/gsg213/Sudoku-Recognizer/blob/master/Img/image1.JPG

# Description
The use of KNN is recommended for the recognition of digits and letters in a simpler way. The data set I use is capable of recognizing letters as well. The first thing is to load the training data and labels of the text documents, reorganize the labels in a vector, create the KNN and start the training with the loaded data. I assign variables of img_w and img_h for the resize, and the img_h is of greater value since the digits are usually higher than wide, in addition these values are chosen as the training data are of size 600 therefore the resize 20x30 . I select a size of 504 to be able to extract good size images of the digits and not lose pixels in the process. 
![My image](https://github.com/gsg213/Sudoku-Recognizer/blob/master/Img/image1.JPG)
Charge the original image and create two copies for comparisons then, the gray scale step and I apply a bilateral filter to eliminate noise but keep most of the edges, the filter parameters were found by testing until it was found the one that best eliminates noise and leaves better lines, I apply an adaptive threshold, with the parameter of cv2.THRESH_BINARY_INV to be able to invert the image and obtain the traces in white, and then expand the image with a square structuring element of 3x3 and leave the strokes thicker. I apply the Findcontours to find all the contours within the image, and with the cycle for I go through all the contours and I compare the area of the previous contour with that of the current one to accumulate the larger area until all the contours are completely gone and I stayed the biggest, which is going to be the sudoku box. Approximate that contour to a square to obtain the 4 points of the corners of that contour, I pass those values to the subroutine corners where I add the values of all the corners and I extract the biggest and the smallest with which I obtain the coordinates superior left and lower right, and then I make a difference between the coordinates and get the upper right and lower left points, and arrange them in the same order as pts2. 
![My image3](https://github.com/gsg213/Sudoku-Recognizer/blob/master/Img/image3.JPG)
I assign the points from pts2 to a value of 504 that I had already chosen and put them in the getPerspectiveTransform function that allows me to calculate the values to fit the outline to the box I want. Then I use warpPerspective to cut out the contour and deform it to the size I chose, I made an erosion with the same structuring element that I had created from the new image to reduce the contours a bit and the digits look thinner. I re-apply Findcontours to detect all the contours within the sudoku, and through the cycle I scroll through all the contours and calculate the areas of each contour and filter the areas between 120 and 600 numbers obtained by performing trial and error to find the range of the areas of the digits, I use the Boundingrect function to obtain the coordinates and points w and h that indicate the width and height of the contour enclosed by a box. With a conditional filter the heights to leave out unwanted contours, with the values of the Boundingrect I make a cut of the warp image I give it a new size with the resize to obtain the 600 pixels that I then organize in a vector of 1x600 and I return them float32 (since this is the data with which the KNN was trained) to pass them to the prediction of the KNN, the result becomes an int and then I use the chr () function since the outputs are encoded in ASCII. I calculate the position of the image inside the grid, finding the coordinate of the center point of the digit adding half the width and the height to the coordinate and divided by 56. I keep these values in a matrix and the step to a subroutine that crosses columns and rows to display on screen much like the grid of sudoku.
![My image2](https://github.com/gsg213/Sudoku-Recognizer/blob/master/Img/imagen2.JPG)
